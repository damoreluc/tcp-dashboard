<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCP Dashboard (WebGL)</title>
    <!-- Plotly with WebGL traces (scattergl) -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
        }
        #charts {
            width: 100%;
            height: 500px;
            margin-bottom: 30px;
            border: 2px solid #333;
        }
    </style>
</head>
<body>  
    <h1>TCP Dashboard</h1>
    <h2>Real-time Data Visualization (WebGL)</h2>

    <!-- Plotly needs a div, not canvas -->
    <div id="charts"></div>

    <script>
        const CHANNELS = 5;
        const MAX_POINTS = 100;        // keep this many points per trace
        const UPDATE_INTERVAL_MS = 33;  // ~30 FPS
        const pending = [];

        // fixed vertical axis range (calibration)
       const Y_MIN = -100;
       const Y_MAX = 100;

        // create empty traces (scattergl = WebGL)
        const traces = Array.from({ length: CHANNELS }, (_, i) => ({
            x: [],
            y: [],
            mode: 'lines',
            type: 'scattergl',
            name: `Channel ${i + 1}`,
            line: { width: 2, color: `hsl(${(i * 45) % 360}, 70%, 50%)` }
        }));

        const layout = {
            margin: { t: 30 },
            xaxis: { title: 'Time', type: 'date' },
            yaxis: { title: 'Value' },
        // FIXED vertical axis: explicit range + autorange:false
        yaxis: {
            title: 'Value',
            range: [Y_MIN, Y_MAX],
            autorange: false
        },
            legend: { orientation: 'h' }
        };

        const config = { responsive: true, displayModeBar: false };

        Plotly.newPlot('charts', traces, layout, config);

        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = `${location.hostname}:8080`;
        const path = '/';
        const ws = new WebSocket(`${protocol}//${host}${path}`);

        ws.onopen = () => console.log('WebSocket open', ws.url);

        ws.onmessage = (ev) => {
            try { pending.push(JSON.parse(ev.data)); } catch (e) { /* ignore */ }
        };

        ws.onclose = ws.onerror = () => { pending.length = 0; };

        // periodic updater: batch messages into per-trace x/y arrays, then extend traces once
        setInterval(() => {
            if (pending.length === 0) return;

            const batch = pending.splice(0, pending.length);

            // prepare arrays for Plotly.extendTraces: one inner array per trace
            const xArrays = Array.from({ length: CHANNELS }, () => []);
            const yArrays = Array.from({ length: CHANNELS }, () => []);

            for (const msg of batch) {
                // use epoch ms for date axis (Plotly accepts numbers)
                const t = Date.parse(msg.timestamp);
                for (let i = 0; i < CHANNELS; i++) {
                    xArrays[i].push(t);
                    yArrays[i].push(msg.values[i]);
                }
            }

            const traceIndices = Array.from({ length: CHANNELS }, (_, i) => i);
            Plotly.extendTraces('charts', { x: xArrays, y: yArrays }, traceIndices, MAX_POINTS);

        }, UPDATE_INTERVAL_MS);

        // optional: also clear pending on ws close/error to free memory
        ws.onclose = ws.onerror = () => pending.length = 0;   

    </script>
</body>
</html>